<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>NYC E&W</title>
        <script type="text/javascript" src="d3/d3.js"></script>
        <script type="text/javascript" src="d3/d3-scale-chromatic.v1.min.js"></script>
        <link rel="stylesheet" type="text/css" href="css/style.css" media="screen" />
    </head>
    <body>
    <div class="content">
      <!--Menu-->
      <div class="navbar">
        <a href="#home">test1</a>
        <a href="#news">test2</a>
        <div class="dropdown">
          <button class="dropbtn" onclick="xaxis_func()">X-axis
            <i class="fa fa-caret-down"></i>
          </button>
          <div class="dropdown-content" id="x_axis_selector">
          </div>
        </div>


        <div class="dropdown">
          <button class="dropbtn" onclick="yaxis_func()">Y-axis
            <i class="fa fa-caret-down"></i>
          </button>
          <div class="dropdown-content" id="y_axis_selector">
          </div>
        </div>
      </div>

      <script>
      function xaxis_func(){
          document.getElementById("x_axis_selector").classList.toggle("show_x");
          if (document.getElementById("y_axis_selector").classList.contains("show_y"))
          {
          document.getElementById("y_axis_selector").classList.toggle("show_y");
          }
      }
      function yaxis_func(){
          document.getElementById("y_axis_selector").classList.toggle("show_y");
          if (document.getElementById("x_axis_selector").classList.contains("show_x"))
          {
          document.getElementById("x_axis_selector").classList.toggle("show_x");
          }
      }
      </script>
    <!--Menu end-->

    <div class="scatter_div"></div>

    <script>
    //Initializing
    //Getting client resolution
    var client_res=[window.screen.width, window.screen.height];
    console.log("client res: "+client_res);
    var svg_to_screen_ratio=0.6;
    var map_to_screen_ratio=0.42;
    var scatter_to_screen_ratio=0.45;
    var map_dot_size = 10e-4*client_res[1];
    var scatter_dot_size = 2.5e-3*client_res[1];

    /////////////////////////// Initialize SVG /////////////////////////////////
    //NEW
    var svg_width=client_res[1]*svg_to_screen_ratio;
    var svg_height=svg_width*1.4;
    var margin = {top: 0, right: 20, bottom: 20, left: 20};
    var svg_w = svg_width - margin.left - margin.right;
    var svg_h = svg_height - margin.top - margin.bottom;

    var svg = d3.select(".scatter_div")
                        .append("svg")
                        .attr("width", (svg_width))
                        .attr("height", (svg_height))
                        .append("g")
                        .attr("transform", "translate("+margin.left+","+margin.top+")");
    svg.append("rect")
    .attr("class", "border_rect")
       .attr("width",(svg_width))
       .attr("height", (svg_height))
       .attr("x", -margin.left)
       .attr("y", -margin.top)
       .attr("stroke", "rgb(200,200,200)")
    svg.append("rect")
     .attr("class", "border_rect_inner")
        .attr("width",(svg_w))
        .attr("height", (svg_h))
        .attr("x", 0)
        .attr("y", 0)
        .attr("stroke", "rgb(200,200,200)")

    //END OF NEW
    ////////////////////// Initialize Scatter Plot /////////////////////////////
    var scatter_width=svg_w;
    var scatter_height=scatter_width*0.7;
    var scatter_margin = {top: 50, right: 70, bottom: 40, left: 70};
    var scatter_w = scatter_width - scatter_margin.left - scatter_margin.right;
    var scatter_h = scatter_height - scatter_margin.top - scatter_margin.bottom;

    var scatter_svg = svg.append("g")
                        .attr("transform", "translate("+scatter_margin.left+","+scatter_margin.top+")");
    scatter_svg.append("clipPath")
               .attr("id", "scatter_clip")
               .append("rect")
               .attr("x",0)
               .attr("y", 0)
               .attr("width",scatter_w)
               .attr("height",scatter_h);

    scatter_svg.append("rect")
    .attr("class", "scatter_rect")
       .attr("width",(scatter_width))
       .attr("height", (scatter_height))
       .attr("x", -scatter_margin.left)
       .attr("y", -scatter_margin.top)
       .attr("stroke", "rgb(200,200,200)")
     scatter_svg.append("rect")
     .attr("class", "scatter_rect_inner")
        .attr("width",(scatter_w))
        .attr("height", (scatter_h))
        .attr("x", 0)
        .attr("y", 0)
        .attr("stroke", "rgb(200,200,200)")

    //////////////////////// Initialize NYC MAP ////////////////////////////////

    //Defining margins and svg element for MAP

    //NEW
    var map_width=client_res[1]*map_to_screen_ratio;
    var map_height=map_width;
    var map_margin = {top: 20, right: 20, bottom: 20, left: 20};
    var map_w = map_width - map_margin.left - map_margin.right;
    var map_h = map_height - map_margin.top - map_margin.bottom;

    var map_svg = svg.append("g")
                    .attr("transform", "translate("+(map_margin.left+(svg_w-map_width)/2)+","+
                      (map_margin.top+scatter_height)+")");

    map_svg.append("rect")
    .attr("class", "test_rect_bg")
       .attr("width",(map_width))
       .attr("height", (map_height))
       .attr("x", -map_margin.left)
       .attr("y", -map_margin.top)
       .attr("stroke", "rgb(200,200,200)")

    //Inner test rect, also MAP BG used for ZOOM, keep it.
    map_svg.append("rect")
    .attr("class", "test_rect map_bg")
       .attr("width",(map_w))
       .attr("height", (map_h))
       .attr("x", 0)
       .attr("y", 0)
       .attr("stroke", "rgb(200,200,200)")
    //END OF NEW




    //Defining path generator
    var map_scale = map_height*85;
    var map_center = [-73.95,40.685];
    var projection = d3.geoMercator()
                       .center(map_center)
                       .scale(map_scale)
                       .translate([map_width/2,map_height/2]);

    var path = d3.geoPath()
                 .projection(projection);

    //CLIPPING on MAP
    map_svg.append("clipPath")
       .attr("id","map_clip")
       .append("rect")
       .attr("x",0)
       .attr("y",0)
       .attr("width",map_w)
       .attr("height",map_h);

    var map = map_svg.append("g").attr("clip-path","url(#map_clip)");

    ////////////////////////////////////////////////////////////////////////
    /////////////////////////////// LOADING DATA ///////////////////////////
    ////////////////////////////////////////////////////////////////////////

    //Variables for debugging
    var ew_data=[];
    var ew_data_full=[];
    var map_data=[];
    /*var x_selection=[];
    var y_selection=[];
    var xScale=[];
    var yScale=[];*/
    var clicked_boro=[];
    var boro_info={};
    var ew_data_subset=[];
    var tmp_drop_element;
    var dropdown_menu;
    var debug;
    var scatter_update;
    var scatter_title_string;
    var x_brush;
    var y_brush;
    var x_val;
    var y_val;
    var map_update;

    var zoomed=false;

    //Defining the row converter function
    var rowConverter = function(d)
    {

      if (d.Longitude!="")
      {
      return  {
              //IF UPDATED-> ALSO UPDATE DROPDOWN DICT
              year_built: parseFloat(d.year_built.replace(",","")),
              gfa: parseFloat(d.DOF_gross_floor_area),
              es_score: parseFloat(d.energy_star_score),
              tot_ghg: parseFloat(d.total_GHG_emissions),
              water_use: parseFloat(d.water_use),
              num_buildings: parseFloat(d.number_of_buildings),
              wn_site_eui: parseFloat(d.wn_site_eui),
              wn_source_eui: parseFloat(d.wn_source_eui),
              wn_site_electricity_intensity: parseFloat(d.wn_site_electricity_intensity),
              electricity_use_grid_purchase: parseFloat(d.electricity_use_grid_purchase),
              wn_site_electricity: parseFloat(d.wn_site_electricity),
              lon: parseFloat(d.Longitude),
              lat: parseFloat(d.Latitude),
              boro: d.borough
      }
      };
    }

    d3.csv("/data/energy_water_2016_filtered.csv",rowConverter,function(data)
    {

      ew_data_full=data;
      ew_data=data;

      var map_dots=map_svg.append("g").attr("clip-path","url(#map_clip)");

      map_dots.selectAll("circle")
             .data(ew_data)
             .enter()
             .append("circle")
             .attr("class", "map_dot")
             .attr("cx", function(d,i)
              {
                var tmp=projection([d.lon,d.lat])
                //console.log("cx index: "+i)
                return tmp[0];
              })
             .attr("cy", function(d,i)
              {
                var tmp=projection([d.lon,d.lat])
                //console.log("cy index: "+i)
                return tmp[1];
              })
             .attr("r", map_dot_size)
             .attr("opacity",0.5);

      ///////////////////////////////SCATTER PLOT//////////////////////////////

      /////////////////////////////DROPDOWN MENU///////////////////////////////
      //dictionary for nicer button text
      dict =
      {
        year_built: "Year built",
        gfa: "Gross Floor Area [ft\u00B2]",
        es_score: "Energy Star Score [1-100]",
        tot_ghg: "Total GHG Emissions [metric tons CO\u00B2e]",
        num_buildings: "Number of buildings on property",
        water_use: "Water use [kgal]",
        lon: "Longitude",
        lat: "Latitude",
        wn_site_eui: "Weather Norm. site EUI [kBTU/ft\u00B2]",
        wn_source_eui: "Weather Norm. source EUI [kBTU/ft\u00B2]",
        wn_site_electricity_intensity: "Weather normalized site electricity intensity [kWh/ft\u00B2]",
        electricity_use_grid_purchase: "Electricity use, grid purchase [kBTU]",
        wn_site_electricity: "Weather Norm. Electricity [kWh]",
        boro: "NYC Borough"
      }

      //Populating dropdown menu with possible variables
      var variables=Object.keys(ew_data_full[0]);

      dropdown_menu_x=d3.selectAll(".dropdown-content")._groups[0][0];
      dropdown_menu_y=d3.selectAll(".dropdown-content")._groups[0][1];

      for (var i=0;i<variables.length-1;i++) //loop length modified to stop before boro for now
      {
        tmp_drop_element = document.createElement("a");
        var tmp_drop_text = document.createTextNode(dict[variables[i]]);

        tmp_drop_element.appendChild(tmp_drop_text); //for x-axis
        tmp_drop_element.className = "drop dropx "+variables[i];
        tmp_drop_element_cln=tmp_drop_element.cloneNode(true); //clone for y-axis
        tmp_drop_element_cln.className = "drop dropy "+variables[i];

        dropdown_menu_x.appendChild(tmp_drop_element);
        dropdown_menu_y.appendChild(tmp_drop_element_cln);
      }

      //Default selection for X- and Y-axis
      x_selection="year_built";
      document.getElementsByClassName("dropx year_built")[0].classList.toggle("drop_selected");
      y_selection="lat";
      document.getElementsByClassName("dropy wn_source_eui")[0].classList.toggle("drop_selected");

      //Dropdown selection function
      window.onclick = function(d) {

        if (d.target.matches('.drop')) {
          drop_selection = d.target.classList[2];
          //Selecting variables and calling scatter_update based on if it's x or y axis
          if (d.target.classList.contains("dropx"))
          {
            x_selection=drop_selection;
          }
          else
          {
            y_selection=drop_selection;
          }
          //Calling the update
          scatter_update(x_selection, y_selection);

          console.log(drop_selection)
          debug = d.target;

          //Styling the selected menu item
          if (d.target.classList.contains("dropx"))
          {
            if (typeof document.getElementsByClassName("dropx drop_selected")[0] !== 'undefined')
            {
              document.getElementsByClassName("dropx drop_selected")[0].classList.toggle("drop_selected");
            }
            d.target.classList.toggle("drop_selected");
          }
          else
          {
            if (typeof document.getElementsByClassName("dropy drop_selected")[0] !== 'undefined')
            {
              document.getElementsByClassName("dropy drop_selected")[0].classList.toggle("drop_selected");
            }
            d.target.classList.toggle("drop_selected");
          }
        }
      }

      ////////////////////////END OF DROPDOWN MENU/////////////////////////////

      //SCALES - creating new variables
      var x_min=d3.min(ew_data, function(d) { return d[x_selection]; });
      var x_max=d3.max(ew_data, function(d)
                                {
                                  //FILTERING EUI - later it should be a variable
                                  if (d[x_selection]<3000)
                                  {
                                    return d[x_selection];
                                  }
                                });
      var y_min=d3.min(ew_data, function(d) { return d[y_selection]; });
      var y_max=d3.max(ew_data, function(d)
                                {
                                  //FILTERING EUI - later it should be a variable
                                  if (d[y_selection]<3000)
                                  {
                                    return d[y_selection];
                                  }
                                });

      xScale=d3.scaleLinear()
               .domain([1827,
                        x_max])
               .range([0,scatter_w]);

      yScale=d3.scaleLinear()
               .domain([y_min,
                        y_max])
               .range([scatter_h,0]);
      //END OF scales
      // SCATTER AXES, LABELS AND TITLE

      var xAxis = d3.axisBottom()
             .scale(xScale)
             .ticks();

      //Define Y axis
      var yAxis = d3.axisLeft()
             .scale(yScale)
             .ticks();

      var xaxis_g = scatter_svg.append("g")
        .attr("class", "axis xaxis")
        .attr("transform", "translate(0," + scatter_h + ")");

      xaxis_g.call(xAxis);

      var yaxis_g = scatter_svg.append("g")
        .attr("class", "axis yaxis");

      yaxis_g.call(yAxis);

      //LABELS
      var xlabel = scatter_svg.append("g")
                              .attr("class","label xlabel")
                              .append("text")
                              .attr("x",scatter_w/2)
                              .attr("y",(scatter_h+35))
                              .attr("text-anchor","middle")
                              .text(dict[x_selection])

      var ylabel = scatter_svg.append("g")
                              .attr("class","label ylabel")
                              .append("text")
                              .attr("x",-scatter_h/2)
                              .attr("y",-50)
                              .attr("transform", "rotate(-90)")
                              .attr("text-anchor", "middle")
                              .text(dict[y_selection])


      var scatter_title_string = dict[x_selection]+" as a function of "+dict[y_selection];
      var title_length = scatter_title_string.length;
      var title_size = "16px";
      var scatter_title = scatter_svg.append("g")
                                     .attr("class","scatter_title")
                                     .append("text")
                                     .attr("x",scatter_w/2)
                                     .attr("y",-20)
                                     .attr("text-anchor", "middle")
                                     .attr("font-size",title_size)
                                     .text(scatter_title_string)
      // END OF SCATTER AXES, LABELS AND TITLE

      //Drawing scatter-plot
      var scatter_dots=scatter_svg.append("g").attr("clip-path","url(#scatter_clip)"); //reference clip path here
      scatter_dots.selectAll("circle")
                  .data(ew_data)
                  .enter()
                  .append("circle")
                  .attr("class", "scatter_dot")
                  .attr("cx",function(d)
                    {
                      if (isNaN(d[x_selection]))
                        {
                          //console.log("it's nan")
                          return xScale(x_min+5000);
                        }
                        else
                        {
                          return xScale(d[x_selection]);
                        }
                    })
                  .attr("cy",function(d,i)
                    { if (isNaN(d[y_selection]))
                      {
                        //console.log("it's nan")
                        return yScale(y_min+5000);
                      }
                      else
                      {
                        return yScale(d[y_selection]);
                      }
                    })
                  .attr("r",scatter_dot_size)
                  .attr("opacity", 0.75)
                  .append("title")
                  .text(function(d)
                        {
                          return x_selection+": "+d[x_selection]+", "+y_selection+": "+d[y_selection];
                        });

      //FUNCTION for DYNAMIC SCATTER PLOT UPDATE and MAP_UPDATE
      scatter_update = function scatter_update_func(x_var,y_var)
      {
        //Updating SCALES
        ew_data = ew_data_full;
        x_min=d3.min(ew_data, function(d) { return d[x_var]; });
        x_max=d3.max(ew_data, function(d)
                                  {
                                    //FILTERING EUI - later it should be a variable
                                    if (d[x_var]<3000)
                                    {
                                      return d[x_var];
                                    }
                                  });
        y_min=d3.min(ew_data, function(d) { return d[y_var]; });
        y_max=d3.max(ew_data, function(d)
                                  {
                                    //FILTERING EUI - later it should be a variable
                                    if (d[y_var]<3000)
                                    {
                                      return d[y_var];
                                    }
                                  });
        xScale=d3.scaleLinear()
                 .domain([x_min,
                          x_max])
                 .range([0,scatter_w]);

        yScale=d3.scaleLinear()
                 .domain([y_min,
                          y_max])
                 .range([scatter_h,0]);


        //ENTER
        scatter_dots.selectAll("circle")
                    .data(ew_data)
                    .enter()
                    .append("circle")
                    .attr("class", "scatter_dot")
                    .attr("cx",function(d)
                      {
                        if (isNaN(d[x_var]))
                          {
                            //console.log("it's nan")
                            return xScale(x_min+5000);
                          }
                          else
                          {
                            return xScale(d[x_var]);
                          }
                      })
                    .attr("cy",function(d,i)
                      { if (isNaN(d[y_var]))
                        {
                          //console.log("it's nan")
                          return yScale(y_min+5000);
                        }
                        else
                        {
                          return yScale(d[y_var]);
                        }
                      })
                    .attr("r",scatter_dot_size)
                    .attr("opacity", 0.75)
                    .append("title")
                    .text(function(d)
                          {
                            return x_var+": "+d[x_var]+", "+y_var+": "+d[y_var];
                          });
        //EXIT
        scatter_dots.selectAll("circle")
                    .data(ew_data)
                    .exit()
                    .remove();

        //UPDATE
        if (ew_data.length<1000)
        {
          var scatter_update_selection = scatter_dots.selectAll("circle")
                                                      .data(ew_data)
                                                      .transition()
                                                      .duration(500);
        }
        else
        {
          var scatter_update_selection = scatter_dots.selectAll("circle")
                                                     .data(ew_data);
        }
        scatter_update_selection.attr("cx",function(d)
                      {
                        if (isNaN(d[x_var]))
                          {
                            //console.log("it's nan")
                            return xScale(x_min+5000);
                          }
                          else
                          {
                            return xScale(d[x_var]);
                          }
                      })
                    .attr("cy",function(d,i)
                      { if (isNaN(d[y_var]))
                        {
                          //console.log("it's nan")
                          return yScale(y_min+5000);
                        }
                        else
                        {
                          return yScale(d[y_var]);
                        }
                      })
                    .attr("r",scatter_dot_size)
                    .attr("opacity", 0.75)
                    .text(function(d)
                          {
                            return x_var+": "+d[x_var]+", "+y_var+": "+d[y_var];
                          });


        //UPDAING SCALES, LABELS AND TITLE
        xAxis = d3.axisBottom()
               .scale(xScale)
               .ticks();

        yAxis = d3.axisLeft()
               .scale(yScale)
               .ticks();

        xaxis_g.transition().call(xAxis);
        yaxis_g.transition().call(yAxis);

        xlabel.text(dict[x_selection]);
        ylabel.text(dict[y_selection]);

        scatter_title_string = dict[x_selection]+" as a function of "+dict[y_selection];
        title_length = scatter_title_string.length;
        if (title_length>75)
        {
          title_size = "14px";
        }
        else
        {
          title_size = "16px";
        }

        scatter_title.attr("font-size", title_size)
                     .text(scatter_title_string);

        //Calling brushed() to keep the map updated
        brush_g.call(brush.move, init_range);
        brushed()


      }
      map_update = function map_update_func(data)
      {
        //ENTER
        map_dots.selectAll("circle")
               .data(data)
               .enter()
               .append("circle")
               .attr("class", "map_dot")
               .attr("cx", function(d,i)
                {
                  var tmp=projection([d.lon,d.lat])
                  return tmp[0];
                })
               .attr("cy", function(d,i)
                {
                  var tmp=projection([d.lon,d.lat])
                  return tmp[1];
                })
               .attr("r", map_dot_size)
               .attr("opacity",0.5);
         //EXIT
         map_dots.selectAll("circle")
                 .data(data)
                 .exit()
                 .remove();
        //UPDATE
        map_dots.selectAll("circle").data(data)
                         .attr("cx", function(d,i)
                         {
                           var tmp=projection([d.lon,d.lat])
                           return tmp[0];
                         })
                        .attr("cy", function(d,i)
                         {
                           var tmp=projection([d.lon,d.lat])
                           return tmp[1];
                         })

      }
      //BRUSH

      //Defining brush
      var brush = d3.brush()
          .extent([[0, 0], [scatter_w, scatter_h]])
          .on("brush", brushed);

      var init_range = [[20, 100], [scatter_w-20, 150]];

      var brush_g = scatter_svg.append("g")
      brush_g.attr("class", "brush")
             .call(brush)
            .call(brush.move, init_range);

      var s;
      var s_init;

      function brushed()
      {
        if (d3.event==null)
        {
          s = s_init;
        }
        else
        {
          s_init = d3.event.selection;
          s = s_init;
        }

        x_brush = [s[0][0], s[1][0]];
        y_brush = [s[0][1], s[1][1]];
        x_val = x_brush.map(xScale.invert, xScale);
        y_val = y_brush.map(yScale.invert, yScale);

        //Get subset of data based on selections
        //filter based on borough
        ew_data=ew_data_full.filter(function(d)
               {
                 return d[x_selection] > x_val[0] && d[x_selection] < x_val[1] &&
                        d[y_selection] > y_val[1] && d[y_selection] < y_val[0];
               })
        //Call map update function
        map_update(ew_data)
      }

      //END OF BRUSH
      ///////////////////////////END OF SCATTER PLOT///////////////////////////

      ////////////////////////////////MAP//////////////////////////////////////
      //Loading GeoJSON file of boroughs
      d3.json("/data/boroughs.json", function(data)
      {
      map_data=data;
      map.selectAll("path")
         .data(data.features)
         .enter()
         .append("path")
         .attr("class",function(d,i)
          {
            return data.features[i].properties.BoroName + " boro_path";
          })
         .attr("d",path);

       /////////////////////////////// ZOOMING ////////////////////////////////
      //Zoom information for each borough
       boro_info=
       {
          "Manhattan": {center: [-73.975,40.78], scale: 2.5},
          "Queens": {center: [-73.836889,40.66], scale: 1.7},
          "Bronx": {center: [-73.856734, 40.848719], scale: 2.5},
          "Brooklyn": {center: [-73.952215, 40.644117], scale: 2.4},
          "Staten_Island": {center: [-74.150945,40.583156], scale: 2.2}
       };

       d3.selectAll('.boro_path,.map_bg')
         .on('click', zoom);

       var current_boro;
       var new_boro;
       var zoom_center;
       var zoom_scale;

       function zoom()
       {
         clicked_boro=d3.select(this)
         if (clicked_boro._groups[0][0].classList[0]=="test_rect")
         {
           //If we are already zoomed out then exit function
           if(zoomed==false)
           {
             return;
           }
           //if it's the background, then act like it's the curren_boro and zoom out
           new_boro=current_boro;
         }
         else
         {
           //else we check for the selected borough's name
          new_boro=d3.select(this)._groups[0][0].__data__.properties.BoroName;
         }

         if (new_boro==current_boro) //If we click on the current boro
         {
           //then use the default scale and center to zoom out
           zoom_center = map_center;
           zoom_scale = 1;
           current_boro="no_zoom";
           zoomed=false;
         }
         else
         {
            current_boro=new_boro;
            zoom_center=boro_info[current_boro].center;
            zoom_scale=boro_info[current_boro].scale;
            zoomed=true;
         }
         projection = d3.geoMercator()
                        .center(zoom_center)
                        .scale(map_scale*zoom_scale)
                        .translate([map_width/2,map_height/2]);

         path = d3.geoPath()
                  .projection(projection);

         //Filtering DATA based on selected boroughs
         if (current_boro!="no_zoom")
         { //filter based on borough
           var ew_data_zoomed=ew_data.filter(function(d)
                  {
                    return d.boro==current_boro;
                  })

         }
         else
         { //else if we zoom out just use the full dataset
           var ew_data_zoomed = ew_data;
         }


         map.selectAll("path")
            .data(data.features)
            .transition()
            .attr("d",path);

         //Calling map_update
         map_update(ew_data_zoomed);

        //Zoom styling of boros
          if (zoomed)
          {
            for (var i=0; i<5; i++)
            {
              var tmp_boro=Object.keys(boro_info)[i];
              var tmp_boro_selection=d3.select("."+tmp_boro);
              if (!tmp_boro_selection.classed(current_boro))
              {
                tmp_boro_selection.classed("zoom_fade",true);
                tmp_boro_selection.classed("zoom_hl",false);

              }
              else
              {
                tmp_boro_selection.classed("zoom_hl",true);
                tmp_boro_selection.classed("zoom_fade",false);
              }
            }
          }
          else
          {
            for (var i=0; i<5; i++)
            {
              var tmp_boro=Object.keys(boro_info)[i];
              var tmp_boro_selection=d3.select("."+tmp_boro);
              tmp_boro_selection.classed("zoom_fade",false);
              tmp_boro_selection.classed("zoom_hl",false);
            }
          }
        }//end of zoom
      })
      ////////////////////////// END OF ZOOMING ////////////////////////////////

      ///////////////////////////END OF MAP////////////////////////////////////
    })

    </script>
    </div>

    </body>
</html>
