<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>NYC E&W</title>
        <script type="text/javascript" src="d3/d3.js"></script>
        <script type="text/javascript" src="d3/d3-scale-chromatic.v1.min.js"></script>
        <link rel="stylesheet" type="text/css" href="css/style.css" media="screen" />
    </head>
    <body>
    <div class="content">
    <!--Menu-->
      <div class="navbar">
        <a href="#home">test1</a>
        <a href="#news">test2</a>
        <div class="dropdown">
          <button class="dropbtn" onclick="xaxis_func()">X-axis
            <i class="fa fa-caret-down"></i>
          </button>
          <div class="dropdown-content" id="x_axis_selector">
          </div>
        </div>


        <div class="dropdown">
          <button class="dropbtn" onclick="yaxis_func()">Y-axis
            <i class="fa fa-caret-down"></i>
          </button>
          <div class="dropdown-content" id="y_axis_selector">
          </div>
        </div>
      </div>
      <script>
      function xaxis_func(){
          document.getElementById("x_axis_selector").classList.toggle("show_x");
          if (document.getElementById("y_axis_selector").classList.contains("show_y"))
          {
          document.getElementById("y_axis_selector").classList.toggle("show_y");
          }
      }
      function yaxis_func(){
          document.getElementById("y_axis_selector").classList.toggle("show_y");
          if (document.getElementById("x_axis_selector").classList.contains("show_x"))
          {
          document.getElementById("x_axis_selector").classList.toggle("show_x");
          }
      }
      </script>
    <!--Menu end-->

    <div class="scatter_div"></div>

      <script>
      //Initializing
      //Getting client resolution
      var client_res=[window.screen.width, window.screen.height];
      console.log("client res: "+client_res);
      var svg_to_screen_ratio=0.55;
      var map_to_screen_ratio=0.42;
      var scatter_to_screen_ratio=0.45;
      var map_dot_size = 10e-4*client_res[1];
      var scatter_dot_size = 2.5e-3*client_res[1];

      /////////////////////////// Initialize SVG /////////////////////////////////
      //NEW
      var svg_width=client_res[1]*svg_to_screen_ratio;
      var svg_height=svg_width*1.5;
      var margin = {top: 20, right: 20, bottom: 20, left: 20};
      var svg_w = svg_width - margin.left - margin.right;
      var svg_h = svg_height - margin.top - margin.bottom;

      var svg = d3.select(".scatter_div")
                          .append("svg")
                          .attr("width", (svg_width))
                          .attr("height", (svg_height))
                          .append("g")
                          .attr("transform", "translate("+margin.left+","+margin.top+")");
      svg.append("rect")
      .attr("class", "border_rect")
         .attr("width",(svg_width))
         .attr("height", (svg_height))
         .attr("x", -margin.left)
         .attr("y", -margin.top)
         .attr("stroke", "rgb(200,200,200)")
      svg.append("rect")
       .attr("class", "border_rect_inner")
          .attr("width",(svg_w))
          .attr("height", (svg_h))
          .attr("x", 0)
          .attr("y", 0)
          .attr("stroke", "rgb(200,200,200)")

      //END OF NEW
      ////////////////////// Initialize Scatter Plot /////////////////////////////
      var scatter_width=svg_w;
      var scatter_height=scatter_width*0.7;
      var scatter_margin = {top: 20, right: 20, bottom: 20, left: 20};
      var scatter_w = scatter_width - scatter_margin.left - scatter_margin.right;
      var scatter_h = scatter_height - scatter_margin.top - scatter_margin.bottom;

      var scatter_svg = svg.append("g")
                          .attr("transform", "translate("+margin.left+","+margin.top+")");
      scatter_svg.append("rect")
      .attr("class", "scatter_rect")
         .attr("width",(scatter_width))
         .attr("height", (scatter_height))
         .attr("x", -scatter_margin.left)
         .attr("y", -scatter_margin.top)
         .attr("stroke", "rgb(200,200,200)")
       scatter_svg.append("rect")
       .attr("class", "scatter_rect_inner")
          .attr("width",(scatter_w))
          .attr("height", (scatter_h))
          .attr("x", 0)
          .attr("y", 0)
          .attr("stroke", "rgb(200,200,200)")

      //////////////////////// Initialize NYC MAP ////////////////////////////////

      //Defining margins and svg element for MAP

      //NEW
      var map_width=client_res[1]*map_to_screen_ratio;
      var map_height=map_width;
      var map_margin = {top: 20, right: 20, bottom: 20, left: 20};
      var map_w = map_width - map_margin.left - map_margin.right;
      var map_h = map_height - map_margin.top - map_margin.bottom;

      var map_svg = svg.append("g")
                      .attr("transform", "translate("+(map_margin.left+(svg_w-map_width)/2)+","+
                        (map_margin.top+scatter_height)+")");

      map_svg.append("rect")
      .attr("class", "test_rect_bg")
         .attr("width",(map_width))
         .attr("height", (map_height))
         .attr("x", -map_margin.left)
         .attr("y", -map_margin.top)
         .attr("stroke", "rgb(200,200,200)")

      //Inner test rect, also MAP BG used for ZOOM, keep it.
      map_svg.append("rect")
      .attr("class", "test_rect map_bg")
         .attr("width",(map_w))
         .attr("height", (map_h))
         .attr("x", 0)
         .attr("y", 0)
         .attr("stroke", "rgb(200,200,200)")
      //END OF NEW




      //Defining path generator
      var map_scale = map_height*85;
      var map_center = [-73.95,40.685];
      var projection = d3.geoMercator()
                         .center(map_center)
                         .scale(map_scale)
                         .translate([map_width/2,map_height/2]);

      var path = d3.geoPath()
                   .projection(projection);

      //CLIPPING on MAP
      map_svg.append("clipPath")
         .attr("id","map_clip")
         .append("rect")
         .attr("x",0)
         .attr("y",0)
         .attr("width",map_w)
         .attr("height",map_h);

      var map = map_svg.append("g").attr("clip-path","url(#map_clip)");

      ////////////////////////////////////////////////////////////////////////
      /////////////////////////////// LOADING DATA ///////////////////////////
      ////////////////////////////////////////////////////////////////////////

      //Variables for debugging
      var ew_data=[];
      var ew_data_full=[];
      var map_data=[];
      /*var x_selection=[];
      var y_selection=[];
      var xScale=[];
      var yScale=[];*/
      var clicked_boro=[];
      var boro_info={};
      var ew_data_subset=[];
      var tmp_drop_element;
      var dropdown_menu;
      var debug;
      var scatter_update;

      var zoomed=false;

      //Defining the row converter function
      var rowConverter = function(d)
      {

        if (d.Longitude!="")
        {
        return  {
                //IF UPDATED-> ALSO UPDATE DROPDOWN DICT
                year_built: parseFloat(d.year_built.replace(",","")),
                gfa: parseFloat(d.DOF_gross_floor_area),
                es_score: parseFloat(d.energy_star_score),
                tot_ghg: parseFloat(d.total_GHG_emissions),
                water_use: parseFloat(d.water_use),
                num_buildings: parseFloat(d.number_of_buildings),
                wn_site_eui: parseFloat(d.wn_site_eui),
                wn_source_eui: parseFloat(d.wn_source_eui),
                lon: parseFloat(d.Longitude),
                lat: parseFloat(d.Latitude),
                boro: d.borough
        }
        };
      }

      d3.csv("/data/energy_water_2016_test.csv",rowConverter,function(data)
      {

        ew_data_full=data;
        ew_data=data;

        var map_dots=map_svg.append("g").attr("clip-path","url(#map_clip)");

        map_dots.selectAll("circle")
               .data(ew_data)
               .enter()
               .append("circle")
               .attr("class", "map_dot")
               .attr("cx", function(d,i)
                {
                  var tmp=projection([d.lon,d.lat])
                  //console.log("cx index: "+i)
                  return tmp[0];
                })
               .attr("cy", function(d,i)
                {
                  var tmp=projection([d.lon,d.lat])
                  //console.log("cy index: "+i)
                  return tmp[1];
                })
               .attr("r", map_dot_size)
               .attr("opacity",0.5);

        ///////////////////////////////SCATTER PLOT//////////////////////////////

        /////////////////////////////DROPDOWN MENU///////////////////////////////
        //dictionary for nicer button text
        dict =
        {
          year_built: "Year built",
          gfa: "Gross Floor Area [ft^2]",
          es_score: "Energy Star Score [1-100]",
          tot_ghg: "Total GHG Emissions [metric ton]",
          num_buildings: "Number of buildings on property",
          water_use: "Water use [kgal]",
          lon: "Longitude",
          lat: "Latitude",
          wn_site_eui: "Weather Norm. site EUI [kBTU/f^2]",
          wn_source_eui: "Weather Norm. source EUI [kBTU/f^2]",
          boro: "NYC Borough"
        }

        //Populating dropdown menu with possible variables
        var variables=Object.keys(ew_data_full[0]);

        dropdown_menu_x=d3.selectAll(".dropdown-content")._groups[0][0];
        dropdown_menu_y=d3.selectAll(".dropdown-content")._groups[0][1];

        for (var i=0;i<variables.length-1;i++)
        {
          tmp_drop_element = document.createElement("a");
          var tmp_drop_text = document.createTextNode(dict[variables[i]]);

          tmp_drop_element.appendChild(tmp_drop_text); //for x-axis
          tmp_drop_element.className = "drop dropx "+variables[i];
          tmp_drop_element_cln=tmp_drop_element.cloneNode(true); //clone for y-axis
          tmp_drop_element_cln.className = "drop dropy "+variables[i];

          dropdown_menu_x.appendChild(tmp_drop_element);
          dropdown_menu_y.appendChild(tmp_drop_element_cln);
        }

        //Default selection for X- and Y-axis (will come from selector on page)
        x_selection="year_built";
        document.getElementsByClassName("dropx year_built")[0].classList.toggle("drop_selected");
        y_selection="wn_source_eui";
        document.getElementsByClassName("dropy wn_source_eui")[0].classList.toggle("drop_selected");

        //Dropdown selection function
        window.onclick = function(d) {

          if (d.target.matches('.drop')) {
            drop_selection = d.target.classList[2];
            //Selecting variables and calling scatter_update based on if it's x or y axis
            if (d.target.classList.contains("dropx"))
            {
              x_selection=drop_selection;
            }
            else
            {
              y_selection=drop_selection;
            }
            //Calling the update
            scatter_update(x_selection, y_selection);

            console.log(drop_selection)
            debug = d.target;

            //Styling the selected menu item
            if (d.target.classList.contains("dropx"))
            {
              if (typeof document.getElementsByClassName("dropx drop_selected")[0] !== 'undefined')
              {
                document.getElementsByClassName("dropx drop_selected")[0].classList.toggle("drop_selected");
              }
              d.target.classList.toggle("drop_selected");
            }
            else
            {
              if (typeof document.getElementsByClassName("dropy drop_selected")[0] !== 'undefined')
              {
                document.getElementsByClassName("dropy drop_selected")[0].classList.toggle("drop_selected");
              }
              d.target.classList.toggle("drop_selected");
            }
          }
        }

        ////////////////////////END OF DROPDOWN MENU/////////////////////////////

        //SCALES - creating new variables
        var x_min=d3.min(ew_data, function(d) { return d[x_selection]; });
        var x_max=d3.max(ew_data, function(d)
                                  {
                                    //FILTERING EUI - later it should be a variable
                                    if (d[x_selection]<3000)
                                    {
                                      return d[x_selection];
                                    }
                                  });
        var y_min=d3.min(ew_data, function(d) { return d[y_selection]; });
        var y_max=d3.max(ew_data, function(d)
                                  {
                                    //FILTERING EUI - later it should be a variable
                                    if (d[y_selection]<3000)
                                    {
                                      return d[y_selection];
                                    }
                                  });

        xScale=d3.scaleLinear()
                 .domain([1827,
                          x_max])
                 .range([0,scatter_w]);

        yScale=d3.scaleLinear()
                 .domain([y_min,
                          y_max])
                 .range([scatter_h,0]);
        //END OF scales

        //Drawing scatter-plot
        var scatter_dots=scatter_svg.append("g");
        scatter_dots.selectAll("circle")
                    .data(ew_data)
                    .enter()
                    .append("circle")
                    .attr("class", "scatter_dot")
                    .attr("cx",function(d)
                      {
                        if (isNaN(d[x_selection]))
                          {
                            //console.log("it's nan")
                            return xScale(x_min+5000);
                          }
                          else
                          {
                            return xScale(d[x_selection]);
                          }
                      })
                    .attr("cy",function(d,i)
                      { if (isNaN(d[y_selection]))
                        {
                          //console.log("it's nan")
                          return yScale(y_min+5000);
                        }
                        else
                        {
                          return yScale(d[y_selection]);
                        }
                      })
                    .attr("r",scatter_dot_size)
                    .attr("opacity", 0.75)
                    .append("title")
                    .text(function(d)
                          {
                            return x_selection+": "+d[x_selection]+", "+y_selection+": "+d[y_selection];
                          });

        //FUNCTION for DYNAMIC SCATTER PLOT UPDATE
        scatter_update = function scatter_update_func(x_var,y_var)
        {
          //Updating SCALES
          x_min=d3.min(ew_data, function(d) { return d[x_var]; });
          x_max=d3.max(ew_data, function(d)
                                    {
                                      //FILTERING EUI - later it should be a variable
                                      if (d[x_var]<3000)
                                      {
                                        return d[x_var];
                                      }
                                    });
          y_min=d3.min(ew_data, function(d) { return d[y_var]; });
          y_max=d3.max(ew_data, function(d)
                                    {
                                      //FILTERING EUI - later it should be a variable
                                      if (d[y_var]<3000)
                                      {
                                        return d[y_var];
                                      }
                                    });
          xScale=d3.scaleLinear()
                   .domain([x_min,
                            x_max])
                   .range([0,scatter_w]);

          yScale=d3.scaleLinear()
                   .domain([y_min,
                            y_max])
                   .range([scatter_h,0]);


          //ENTER
          scatter_dots.selectAll("circle")
                      .data(ew_data)
                      .enter()
                      .append("circle")
                      .attr("class", "scatter_dot")
                      .attr("cx",function(d)
                        {
                          if (isNaN(d[x_var]))
                            {
                              //console.log("it's nan")
                              return xScale(x_min+5000);
                            }
                            else
                            {
                              return xScale(d[x_var]);
                            }
                        })
                      .attr("cy",function(d,i)
                        { if (isNaN(d[y_var]))
                          {
                            //console.log("it's nan")
                            return yScale(y_min+5000);
                          }
                          else
                          {
                            return yScale(d[y_var]);
                          }
                        })
                      .attr("r",scatter_dot_size)
                      .attr("opacity", 0.75)
                      .append("title")
                      .text(function(d)
                            {
                              return x_var+": "+d[x_var]+", "+y_var+": "+d[y_var];
                            });
          //EXIT
          scatter_dots.selectAll("circle")
                      .data(ew_data)
                      .exit()
                      .remove();

          //UPDATE
          if (ew_data.length<1000)
          {
            var scatter_update_selection = scatter_dots.selectAll("circle")
                                                        .data(ew_data)
                                                        .transition()
                                                        .duration(500);
          }
          else
          {
            var scatter_update_selection = scatter_dots.selectAll("circle")
                                                       .data(ew_data);
          }
          scatter_update_selection.attr("cx",function(d)
                        {
                          if (isNaN(d[x_var]))
                            {
                              //console.log("it's nan")
                              return xScale(x_min+5000);
                            }
                            else
                            {
                              return xScale(d[x_var]);
                            }
                        })
                      .attr("cy",function(d,i)
                        { if (isNaN(d[y_var]))
                          {
                            //console.log("it's nan")
                            return yScale(y_min+5000);
                          }
                          else
                          {
                            return yScale(d[y_var]);
                          }
                        })
                      .attr("r",scatter_dot_size)
                      .attr("opacity", 0.75)
                      .text(function(d)
                            {
                              return x_var+": "+d[x_var]+", "+y_var+": "+d[y_var];
                            });
        }

        ///////////////////////////END OF SCATTER PLOT///////////////////////////

        ////////////////////////////////MAP//////////////////////////////////////
        //Loading GeoJSON file of boroughs
        d3.json("/data/boroughs.json", function(data)
        {
        map_data=data;
        map.selectAll("path")
           .data(data.features)
           .enter()
           .append("path")
           .attr("class",function(d,i)
            {
              return data.features[i].properties.BoroName + " boro_path";
            })
           .attr("d",path);

         /////////////////////////////// ZOOMING ////////////////////////////////
        //Zoom information for each borough
         boro_info=
         {
            "Manhattan": {center: [-73.975,40.78], scale: 2.5},
            "Queens": {center: [-73.836889,40.66], scale: 1.7},
            "Bronx": {center: [-73.856734, 40.848719], scale: 2.5},
            "Brooklyn": {center: [-73.952215, 40.644117], scale: 2.4},
            "Staten_Island": {center: [-74.150945,40.583156], scale: 2.2}
         };

         d3.selectAll('.boro_path,.map_bg')
           .on('click', zoom);

         var current_boro;
         var new_boro;
         var zoom_center;
         var zoom_scale;

         function zoom()
         {
           clicked_boro=d3.select(this)
           if (clicked_boro._groups[0][0].classList[0]=="test_rect")
           {
             //If we are already zoomed out then exit function
             if(zoomed==false)
             {
               return;
             }
             //if it's the background, then act like it's the curren_boro and zoom out
             new_boro=current_boro;
           }
           else
           {
             //else we check for the selected borough's name
            new_boro=d3.select(this)._groups[0][0].__data__.properties.BoroName;
           }

           if (new_boro==current_boro) //If we click on the current boro
           {
             //then use the default scale and center to zoom out
             zoom_center = map_center;
             zoom_scale = 1;
             current_boro="no_zoom";
             zoomed=false;
           }
           else
           {
              current_boro=new_boro;
              zoom_center=boro_info[current_boro].center;
              zoom_scale=boro_info[current_boro].scale;
              zoomed=true;
           }
           projection = d3.geoMercator()
                          .center(zoom_center)
                          .scale(map_scale*zoom_scale)
                          .translate([map_width/2,map_height/2]);

           path = d3.geoPath()
                    .projection(projection);

           //Filtering DATA based on selected boroughs
           if (current_boro!="no_zoom")
           { //filter based on borough
             ew_data=ew_data_full.filter(function(d)
                    {
                      return d.boro==current_boro;
                    })

           }
           else
           { //else if we zoom out just use the full dataset
             ew_data = ew_data_full;
           }


           map.selectAll("path")
              .data(data.features)
              .transition()
              .attr("d",path);
           //ENTER
           map_dots.selectAll("circle")
                  .data(ew_data)
                  .enter()
                  .append("circle")
                  .attr("class", "map_dot")
                  .attr("cx", function(d,i)
                   {
                     var tmp=projection([d.lon,d.lat])
                     return tmp[0];
                   })
                  .attr("cy", function(d,i)
                   {
                     var tmp=projection([d.lon,d.lat])
                     return tmp[1];
                   })
                  .attr("r", map_dot_size)
                  .attr("opacity",0.5);
            //EXIT
            map_dots.selectAll("circle")
                    .data(ew_data)
                    .exit()
                    .remove();
           //UPDATE
           map_dots.selectAll("circle").data(ew_data)
                            .transition()
                            .attr("cx", function(d,i)
                            {
                              var tmp=projection([d.lon,d.lat])
                              return tmp[0];
                            })
                           .attr("cy", function(d,i)
                            {
                              var tmp=projection([d.lon,d.lat])
                              return tmp[1];
                            })

          //Zoom styling of boros
            if (zoomed)
            {
              for (var i=0; i<5; i++)
              {
                var tmp_boro=Object.keys(boro_info)[i];
                var tmp_boro_selection=d3.select("."+tmp_boro);
                if (!tmp_boro_selection.classed(current_boro))
                {
                  tmp_boro_selection.classed("zoom_fade",true);
                  tmp_boro_selection.classed("zoom_hl",false);

                }
                else
                {
                  tmp_boro_selection.classed("zoom_hl",true);
                  tmp_boro_selection.classed("zoom_fade",false);
                }
              }
            }
            else
            {
              for (var i=0; i<5; i++)
              {
                var tmp_boro=Object.keys(boro_info)[i];
                var tmp_boro_selection=d3.select("."+tmp_boro);
                tmp_boro_selection.classed("zoom_fade",false);
                tmp_boro_selection.classed("zoom_hl",false);
              }
            }
          }//end of zoom
        })
        ////////////////////////// END OF ZOOMING ////////////////////////////////
        ///////////////////////////END OF MAP////////////////////////////////////
      })
      </script>
    </div>

    </body>
</html>
